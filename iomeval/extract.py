"""Report Sections Extraction"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_extract.ipynb.

# %% auto 0
__all__ = ['select_section_sp', 'CoreSectionsOutput', 'rm_nested', 'identify_core_sections', 'extract_sections']

# %% ../nbs/03_extract.ipynb 3
from fastcore.all import *
from operator import getitem
from pydantic import BaseModel
from lisette.core import completion, mk_msg
from toolslm.md_hier import create_heading_dict
import json

# %% ../nbs/03_extract.ipynb 4
class CoreSectionsOutput(BaseModel):
    "Identify the core sections of the report"
    section_paths: list[list[str]]
    reasoning: str

# %% ../nbs/03_extract.ipynb 5
select_section_sp = """### ROLE AND OBJECTIVE
You are an expert evaluation report analyst. Your task is to identify sections that would help determine if specific themes are CORE to this report for synthesis and retrieval purposes.

### CONTEXT
You will receive a table of contents (ToC) as a NESTED DICTIONARY where keys are section headings and values are sub-sections. Return full paths through this hierarchy.

### SECTIONS TO IDENTIFY
Look for sections that reveal core themes (in any language):
1. Executive Summary / Overview / Résumé exécutif / Resumen ejecutivo
2. Introduction / Objectives / Purpose / Questions d'évaluation / Preguntas de evaluación
3. Conclusions / Conclusiones
4. Recommendations / Recommandations / Recomendaciones

### SELECTION CRITERIA
- Match flexibly by meaning, not exact wording
- Prioritize where authors explicitly state what's important
- Aim for ~8-10 pages total (use page numbers in ToC as guide)
- Avoid methodology, background, annexes unless unusually central

### OUTPUT FORMAT
JSON with:
- section_paths: list of paths, each path is a list of EXACT key strings from root to target section
- reasoning: string explaining your choices

**CRITICAL**: Each path must be a list of EXACT key strings from the nested dict, starting from the root.
Example path: ["Root Title ... page 1", "3. CONCLUSIONS ... page 34"]
"""

# %% ../nbs/03_extract.ipynb 12
def rm_nested(paths:list[list[str]] # List of section paths, where each path is a list of keys
             ) -> list[list[str]]: # Filtered list with nested paths removed
    "Remove paths that are children of other paths in the list"
    paths = sorted(paths, key=len)
    keep = []
    for p in paths:
        if not any(p[:len(k)] == k for k in keep): keep.append(p)
    return keep

# %% ../nbs/03_extract.ipynb 15
def identify_core_sections(
    hdgs:dict, # Nested dictionary of report headings from `create_heading_dict`
    sp:str=select_section_sp, # System prompt for section identification
    response_format:type[BaseModel]=CoreSectionsOutput, # Pydantic model for structured output
    model:str='claude-sonnet-4-5' # LLM model to use for identification
) -> dict: # Dictionary with 'section_paths' and 'reasoning' keys
    "Use LLM to identify core sections (exec summary, intro, conclusions, recommendations) from ToC"
    res = completion(model=model, messages=[mk_msg(f"Here is the table of contents as a nested dictionary:\n\n{hdgs}")], 
                     system=[{"type": "text", "text": sp}], response_format=response_format)
    return json.loads(res.choices[0].message.content)

# %% ../nbs/03_extract.ipynb 18
def extract_sections(
    md:str, # Markdown text of full report
    model:str='claude-sonnet-4-5' # LLM model to use for section identification
) -> str: # Concatenated text of all core sections
    "Extract and concatenate core sections (exec summary, intro, conclusions, recommendations) from report markdown"
    hdgs = create_heading_dict(md)
    sections = identify_core_sections(hdgs, model=model)
    paths = rm_nested(sections['section_paths'])
    return '\n'.join([get_text(p, hdgs) for p in paths])
