# Extract


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

This module provides tools for automatically identifying and extracting
core sections from evaluation reports. When working with large reports
(50-200+ pages), we need to focus on key sections—such as executive
summaries, introductions, conclusions, and recommendations—to support
tagging and mapping exercises against evaluation frameworks (e.g., SRF,
GCM).

Focusing on these sections helps:

- Reduce noise from tangential content
- Prevent confirmation bias by avoiding the tendency to flag any passing
  mention as a theme

The approach uses an LLM to parse a report’s table of contents, identify
which sections contain substantive thematic content, and extract just
those sections for further processing.

------------------------------------------------------------------------

<a
href="https://github.com/franckalbinet/iomeval/blob/main/iomeval/extract.py#L19"
target="_blank" style="float:right; font-size:smaller">source</a>

### CoreSectionsOutput

>  CoreSectionsOutput (section_paths:list[list[str]], reasoning:str)

*Identify the core sections of the report*

For instance, given a markdown:

``` python
sample_md = """# Report Title ... page 1

## Executive Summary ... page 1

This is a summary of key findings.

## 1. Introduction ... page 2

Background information here.

### 1.1 Objectives ... page 2

The objectives are...

## 2. Findings ... page 3

Detailed findings.

## 3. Conclusions ... page 5

Main conclusions.

## 4. Recommendations ... page 6

Key recommendations."""
```

``` python
hdgs = create_heading_dict(sample_md)
hdgs
```

    {'Report Title ... page 1': {'Executive Summary ... page 1': {},
      '1. Introduction ... page 2': {'1.1 Objectives ... page 2': {}},
      '2. Findings ... page 3': {},
      '3. Conclusions ... page 5': {},
      '4. Recommendations ... page 6': {}}}

## Navigating Nested Headings

Reports have hierarchical structure (sections, subsections, etc.). We
represent this as a nested dictionary using `create_heading_dict` from
`toolslm.md_hier`. To extract text from a specific section, we need to
navigate through this hierarchy using a path of keys.

------------------------------------------------------------------------

<a
href="https://github.com/franckalbinet/iomeval/blob/main/iomeval/extract.py#L25"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_text

>  get_text (ks:list[str], hdgs:dict)

*Navigate through nested heading levels and return the text content*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ks</td>
<td>list</td>
<td>List of exact key strings forming path through nested dict</td>
</tr>
<tr>
<td>hdgs</td>
<td>dict</td>
<td>Nested dictionary of headings created by
<code>create_heading_dict</code></td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td><strong>Extracted markdown text for the section</strong></td>
</tr>
</tbody>
</table>

``` python
path = ['Report Title ... page 1', '3. Conclusions ... page 5']
print(get_text(path, hdgs))
```

    ## 3. Conclusions ... page 5

    Main conclusions.

## Handling Nested Selections

When the LLM identifies core sections, it might select both a parent
section and its children (e.g., “Introduction” and “Introduction \>
Objectives”). To avoid duplicate content, we filter out any paths that
are children of other selected paths.

------------------------------------------------------------------------

<a
href="https://github.com/franckalbinet/iomeval/blob/main/iomeval/extract.py#L32"
target="_blank" style="float:right; font-size:smaller">source</a>

### rm_nested

>  rm_nested (paths:list[list[str]])

*Remove paths that are children of other paths in the list*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>paths</td>
<td>list</td>
<td>List of section paths, where each path is a list of keys</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>list</strong></td>
<td><strong>Filtered list with nested paths removed</strong></td>
</tr>
</tbody>
</table>

``` python
nested_paths = [
    ['Report Title ... page 1', '1. Introduction ... page 2'],
    ['Report Title ... page 1', '1. Introduction ... page 2', '1.1 Objectives ... page 2'],
    ['Report Title ... page 1', '3. Conclusions ... page 5']
]
rm_nested(nested_paths)
```

    [['Report Title ... page 1', '1. Introduction ... page 2'],
     ['Report Title ... page 1', '3. Conclusions ... page 5']]

## LLM-Based Section Identification

Rather than using rigid pattern matching, we use an LLM to intelligently
identify core sections. This handles multilingual reports, varied naming
conventions, and unusual structures. The LLM receives the table of
contents as a nested dictionary and returns paths to the most relevant
sections.

------------------------------------------------------------------------

<a
href="https://github.com/franckalbinet/iomeval/blob/main/iomeval/extract.py#L42"
target="_blank" style="float:right; font-size:smaller">source</a>

### identify_core_sections

>  identify_core_sections (hdgs:dict, sp:str=None,
>                              response_format:type[pydantic.main.BaseModel]=<cl
>                              ass '__main__.CoreSectionsOutput'>,
>                              model:str='claude-sonnet-4-5')

*Use LLM to identify core sections (exec summary, intro, conclusions,
recommendations) from ToC*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>hdgs</td>
<td>dict</td>
<td></td>
<td>Nested dictionary of report headings from
<code>create_heading_dict</code></td>
</tr>
<tr>
<td>sp</td>
<td>str</td>
<td>None</td>
<td>System prompt for section identification</td>
</tr>
<tr>
<td>response_format</td>
<td>type</td>
<td>CoreSectionsOutput</td>
<td>Pydantic model for structured output</td>
</tr>
<tr>
<td>model</td>
<td>str</td>
<td>claude-sonnet-4-5</td>
<td>LLM model to use for identification</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>dict</strong></td>
<td></td>
<td><strong>Dictionary with ‘section_paths’ and ‘reasoning’
keys</strong></td>
</tr>
</tbody>
</table>

``` python
sections = identify_core_sections(hdgs)
sections
```

    {'section_paths': [['Report Title ... page 1', 'Executive Summary ... page 1'],
      ['Report Title ... page 1',
       '1. Introduction ... page 2',
       '1.1 Objectives ... page 2'],
      ['Report Title ... page 1', '3. Conclusions ... page 5'],
      ['Report Title ... page 1', '4. Recommendations ... page 6']],
     'reasoning': "Selected four core sections totaling approximately 6 pages that capture the report's essential themes: Executive Summary (page 1) provides the overview and key findings; Introduction/Objectives (pages 2-3) establishes the evaluation purpose and questions; Conclusions (pages 5-6) synthesizes findings; and Recommendations (page 6+) presents actionable insights. These sections represent where authors explicitly articulate what is important and core to the evaluation, avoiding the Findings section which likely contains supporting detail rather than thematic synthesis."}

## Putting It All Together

The main entry point combines all the pieces: parse the report
structure, identify core sections, remove nested duplicates, and extract
the text.

------------------------------------------------------------------------

<a
href="https://github.com/franckalbinet/iomeval/blob/main/iomeval/extract.py#L56"
target="_blank" style="float:right; font-size:smaller">source</a>

### extract_sections

>  extract_sections (md:str, sp:str=None,
>                        response_format:type[pydantic.main.BaseModel]=<class
>                        '__main__.CoreSectionsOutput'>, model:str='claude-
>                        sonnet-4-5')

*Extract and concatenate core sections (exec summary, intro,
conclusions, recommendations) from report markdown*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>md</td>
<td>str</td>
<td></td>
<td>Markdown text of full report</td>
</tr>
<tr>
<td>sp</td>
<td>str</td>
<td>None</td>
<td>System prompt for section identification</td>
</tr>
<tr>
<td>response_format</td>
<td>type</td>
<td>CoreSectionsOutput</td>
<td>Pydantic model for structured output</td>
</tr>
<tr>
<td>model</td>
<td>str</td>
<td>claude-sonnet-4-5</td>
<td>LLM model to use for identification</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td></td>
<td><strong>Concatenated text of all core sections</strong></td>
</tr>
</tbody>
</table>

``` python
text = extract_sections(sample_md, model='claude-sonnet-4-5')
print(text[:200])
```

    ## Executive Summary ... page 1

    This is a summary of key findings.
    ## 1. Introduction ... page 2

    Background information here.

    ### 1.1 Objectives ... page 2

    The objectives are...
    ## 3. Conclusions 

## TO DO

The LLM gets sometimes confused when passing the nested dict of
headings. Flattening it might make it more robust…

``` python
def flatten_paths(hdgs, prefix=[]):
    paths = []
    for k, v in hdgs.items():
        current_path = prefix + [k]
        paths.append(current_path)
        if v:  # If there are children
            paths.extend(flatten_paths(v, current_path))
    return paths
```

``` python
hdgs
```

    {'Report Title ... page 1': {'Executive Summary ... page 1': {},
      '1. Introduction ... page 2': {'1.1 Objectives ... page 2': {}},
      '2. Findings ... page 3': {},
      '3. Conclusions ... page 5': {},
      '4. Recommendations ... page 6': {}}}

``` python
for i,o in enumerate(flatten_paths(hdgs)): 
    print((i,o))
```

    (0, ['Report Title ... page 1'])
    (1, ['Report Title ... page 1', 'Executive Summary ... page 1'])
    (2, ['Report Title ... page 1', '1. Introduction ... page 2'])
    (3, ['Report Title ... page 1', '1. Introduction ... page 2', '1.1 Objectives ... page 2'])
    (4, ['Report Title ... page 1', '2. Findings ... page 3'])
    (5, ['Report Title ... page 1', '3. Conclusions ... page 5'])
    (6, ['Report Title ... page 1', '4. Recommendations ... page 6'])
